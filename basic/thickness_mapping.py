from pydicom import dcmread
import cv2
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
import os
from skimage.segmentation import watershed
from skimage.feature import peak_local_max
from scipy import ndimage
from matplotlib.figure import Figure
from django.conf import settings

# dicom to grayscale conversion: helper function to convert raw CT image to grayscale

def dicom_to_gray(ds):

    raw = ds.pixel_array
    raw = raw.astype(float) # convert to float
    raw = (np.maximum(raw,0) / raw.max()) * 255.0 # scale between 0-255
    raw = np.uint8(raw) # convert to uint

    return raw

# Indexing and Sorting CT Slices

def get_slice_idxs(init_axial_path, prox_limit_mm):

    # get path of all axial CTs
    axials_path = '/'.join(init_axial_path.split('/')[:-1])

    # match with Z position
    matched_pos_axial = []
    for path in os.listdir(axials_path):
        # read slice
        ds = dcmread('/'.join([axials_path, path]))

        # compute projection onto imaging axis
        IOP = ds.ImageOrientationPatient
        IPP = ds.ImagePositionPatient
        normal = np.cross(IOP[0:3], IOP[3:])
        slice_pos = np.dot(IPP, normal)

        # record slice position
        matched_pos_axial.append(('/'.join([axials_path, path]), slice_pos))

    # sort by descending Z position (distal to proximal)
    sorted_pos_axial = sorted(matched_pos_axial, key = lambda x: x[1], reverse=True)

    # limit by distal radius range
    # z_coords = list(dict(sorted_pos_axial).values())
    idx_range = int(prox_limit_mm // ds.SliceThickness)
    idx_of_init = list(dict(sorted_pos_axial).keys()).index(init_axial_path)
    idx_of_final = idx_of_init + idx_range #bisect.bisect_left(z_coords, z_coords[-1] - prox_limit_mm)
    limited_pos_axial = sorted_pos_axial[idx_of_init:idx_of_final]

    # return slices with filepath and index
    return limited_pos_axial

# Generating Heatmap

# collect radius bone dimension data for axial cuts of interest

def generate_heatmap(slice_paths, pixel_spacing, slice_thickness, laterality):

    segmented_axials = []
    thicknesses = []
    crosssections = []
    central_axes = []
    midpoints = []
    widths = []

    # segment radius in each slice, and record statistics
    for path in slice_paths:

        # read mask generated by segmentation model
        segmented_initial = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
        _, segmented_initial = cv2.threshold(segmented_initial, 100, 255, cv2.THRESH_BINARY)

        # compute exact Euclidean distance from every binary pixel to nearest zero pixel
        D = ndimage.distance_transform_edt(segmented_initial)

        # find peaks in distance map
        indices = peak_local_max(D, min_distance=20, labels=segmented_initial)
        localMax = np.zeros(segmented_initial.shape, dtype=bool)
        localMax[tuple(indices.T)] = True

        # perform a connected component analysis on local peaks
        markers = ndimage.label(localMax, structure=np.ones((3, 3)))[0]

        # apply watershed algorithm
        labels = watershed(-D, markers, mask=segmented_initial)

        # instantiate final mask
        segmented = np.zeros(segmented_initial.shape, dtype="uint8")

        # loop over unique labels returned by watershed algorithm, and save area
        contour_areas = dict()
        for label in np.unique(labels):

            # ignore background
            if label == 0:
                continue

            # draw label region on component mask
            mask = np.zeros(segmented_initial.shape, dtype="uint8")
            mask[labels == label] = 255

            # detect contours in the component mask
            ctr, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            # handle if empty label
            if len(ctr) == 0: continue

            # non-maximal suppression
            c = max(ctr, key = cv2.contourArea)
            contour_areas[cv2.contourArea(c)] = c

        # find contour with maximum area
        # handle if empty image
        if len(contour_areas) == 0: continue
        c = contour_areas[max(contour_areas.keys())]
        segmented = cv2.drawContours(np.zeros_like(segmented), [c], -1, (255, 0, 255), -1)

        # find contour dimensions
        left_x, top_y, width, height = cv2.boundingRect(c)

        # find thickness at each point of radius
        thickness = []
        thickness.extend(np.zeros_like(segmented[0:left_x])) # pad thickness on left
        for column in segmented[top_y:top_y+height, left_x:left_x+width].T:
            thickness.append(abs(np.nonzero(column)[0][0] - np.nonzero(column)[0][-1]))
        thickness.extend(np.zeros_like(segmented[left_x+width:])) # pad thickness on left

        # find cross-section at midpoint of contour
        crosssection = np.zeros(len(segmented.T))
        crosssection[left_x:left_x+width] = 1

        # find central axis and midpoint
        central_axis = top_y + height / 2
        midpoint = left_x + width / 2

        # record statistics
        segmented_axials.append(segmented)
        thicknesses.append(thickness)
        crosssections.append(crosssection)
        central_axes.append(central_axis)
        midpoints.append(midpoint)
        widths.append(width)

    # generate heatmap from contour data
    hm = np.zeros_like(crosssections)

    for row in range(len(hm)):
        for x in np.nonzero(crosssections[row])[0]:
            hm[row][x] = thicknesses[row][x] * pixel_spacing

    # rescale to appropriate dimension (mm)
    width = int(hm.shape[1] * pixel_spacing)
    height = int(hm.shape[0] * slice_thickness)
    hm = cv2.resize(hm, (width, height))

    # horizontal flip, if left side CT
    if laterality == 1:
        hm = cv2.flip(hm, 1)

    # center and crop to standardize width
    output_width = 100 #mm
    hm_centered = center_and_crop(hm, output_width)

    return hm_centered, segmented_axials, thicknesses, crosssections, central_axes, midpoints, widths

# standardize heatmap

def center_and_crop(binary_image, output_width):
    height, width = binary_image.shape
    centered_image = np.zeros((height, output_width), dtype=np.uint8)

    for row_idx in range(height):
       row = binary_image[row_idx, :]

       # Find the indices of the nonzero pixels in the row
       nonzero_pixel_indices = np.where(row)[0]

       # If there are no nonzero pixels in the row, continue to the next row
       if nonzero_pixel_indices.size == 0:
          continue

       # Get the leftmost and rightmost nonzero pixel indices
       leftmost = nonzero_pixel_indices[0]
       rightmost = nonzero_pixel_indices[-1]

       # Calculate the left padding needed to center the row
       row_content_length = rightmost - leftmost + 1
       left_padding = (width - row_content_length) // 2

       # Center the row content in the original row
       centered_row = np.zeros((width,), dtype=np.uint8)
       centered_row[left_padding:left_padding+row_content_length] = row[leftmost:rightmost+1]

       # Crop or pad the centered row to achieve the desired output_width
       half_diff = abs(output_width - width) // 2

       if output_width > width:
          final_row = np.pad(centered_row, (half_diff, output_width - width - half_diff), constant_values=(0, 0))
       else:
          final_row = centered_row[half_diff:half_diff + output_width]

       # Write the final row to the new image
       centered_image[row_idx, :] = final_row

    return centered_image

#aggregate combined heatmaps
def aggregate_heatmap(heatmaps, output_width, output_height):

    # get sample size
    num_heatmaps = len(heatmaps)

    # iterate over each heatmap and accumulate the padded heatmaps
    heatmaps_padded = []
    
    for hm in heatmaps:

        # pad the heatmap to the output size
        hm_padded = np.zeros((output_height, output_width))
        hm_padded[:hm.shape[0], :] = hm

        # add the padded heatmap to the list of padded heatmaps
        heatmaps_padded.append(hm_padded)

    # stack the padded heatmaps
    heatmaps_stacked = np.stack(heatmaps_padded, axis=0)

    # calculate the average heatmap and error, excluding 0 values
    avg_heatmap = np.zeros((output_height, output_width))
    err_heatmap = np.zeros((output_height, output_width))

    rowwise_heatmaps_stacked = np.swapaxes(heatmaps_stacked, 0, 1)

    for i, stacked_row in enumerate(rowwise_heatmaps_stacked):

        # check if row is all zeros
        is_zeros_row = (stacked_row == 0).all(axis=1)

        # get mean of non-zero rows
        row_mean = np.mean(stacked_row[~is_zeros_row], axis=0)

        # get std error of non-zero rows
        row_err = np.std(stacked_row[~is_zeros_row], axis=0) / np.sqrt(len(stacked_row[~is_zeros_row]))

        # set row of average heatmap and error
        avg_heatmap[i, :] = row_mean
        err_heatmap[i, :] = row_err

    return avg_heatmap, err_heatmap, num_heatmaps

# generate aggregated heatmaps for selected samples, given accession numbers. requires files to be located in heatmap_dir and named by accession number
def filter_combined_heatmaps(filenames, prox_limit_mm=40):


    # load heatmaps from directory
    stacked_heatmaps = [cv2.imread(f'{filename}', cv2.IMREAD_GRAYSCALE) for filename in filenames]
    
    # aggregate all heatmaps
    avg_heatmap, err_heatmap, num_heatmaps = aggregate_heatmap(stacked_heatmaps, output_width=stacked_heatmaps[0].shape[1], output_height=prox_limit_mm)

    return avg_heatmap, err_heatmap, num_heatmaps

# visualize heatmap combined
def visualize_combined_heatmaps(title, hm, err, num, pts):
    fig = Figure()
    ax = fig.subplots()

    # plot aggregate heatmap
    im = ax.imshow(hm, aspect=1.5, cmap=plt.cm.turbo, interpolation='bicubic')
    ax.set_ylabel('Distance from Distal End (mm)')
    ax.set_xlabel('Position (Radial to Ulnar) (mm)')
    #points
    for point in pts:
        [x,y],thickness, point_error = point
        ax.plot(x,y,'o',color='black')
        ax.text(int(x)+2, int(y)-2, f'{round(thickness, 3)}Â±{round(point_error, 3)} mm', color='black', bbox=dict(facecolor='white', edgecolor='black', boxstyle='round', alpha = 0.5))
        
    # colorbar
    cbar = fig.colorbar(im, ax=ax)

    # rotate colorbar label
    cbar.ax.set_ylabel('Thickness (mm)', rotation=270, labelpad=15)
    filename = settings.MEDIA_ROOT + "temp/test.png"

    fig.suptitle(f"{title} ($n = {num}$)")
    fig.savefig(filename)
    
    